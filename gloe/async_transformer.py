import copy\\\\\nimport traceback\\\\\nimport types\\\\\nimport uuid\\\\\nfrom abc import abstractmethod, ABC\\\\\nfrom inspect import Signature\\\\\nfrom typing import TypeVar, overload, cast, Any, Callable, Awaitable\\\\\n\nfrom gloe.base_transformer import (\\\\\n    TransformerException,\\\\\n    BaseTransformer,\\\\\n    PreviousTransformer,\\\\\n)\\\\\n\n__all__ = ['AsyncTransformer']\\\\\\n\\\\\\n_In = TypeVar('_In')\\\\\n_Out = TypeVar('_Out')\\\\\n_NextOut = TypeVar('_NextOut')\\\\\n\\\\\\n_Out2 = TypeVar('_Out2')\\\\\n_Out3 = TypeVar('_Out3')\\\\\n_Out4 = TypeVar('_Out4')\\\\\n_Out5 = TypeVar('_Out5')\\\\\n_Out6 = TypeVar('_Out6')\\\\\n_Out7 = TypeVar('_Out7')\\\\\n\\\\\\nclass AsyncTransformer(BaseTransformer[_In, _Out, 'AsyncTransformer'], ABC):\\\\\\n    def __init__(self):\\\\\\n        super().__init__()\\\\\\n\\\\\\n        self._graph_node_props: dict[str, Any] = {\\\\\n            **self._graph_node_props,\\\\\n            'isAsync': True,\\\\\n        }\\\\\\n        self.__class__.__annotations__ = self.transform_async.__annotations__\\\\\\n    @abstractmethod\\\\\\n    async def transform_async(self, data: _In) -> _Out):\\\\\\n        '''\\\\\\n        Method to perform the transformation asynchronously.\\\\\n\\\\\\n        Args:\\\\\\n            data: the incoming data passed to the transformer during the pipeline execution.\\\\\n\\\\\\n        Return:\\\\\\n            The outcome data, it means, the resulf of the transformation.\\\\\n        '''\\\\\\n        pass\\\\\\n    def signature(self) -> Signature:\\\\\\n        return self._signature(AsyncTransformer)\\\\\n    def __repr__(self):\\\\\\n        return f'{self.input_annotation} -> ({type(self).__name__}) -> {self.output_annotation}'\\\\\\n    async def __call__(self, data: _In) -> _Out:\\\\\\n        transform_exception = None\\\\\\n\\\\\\n        transformed: _Out | None = None\\\\\\n        try:\\\\\\n            transformed = await self.transform_async(data)\\\\\n        except Exception as exception:\\\\\\n            if type(exception.__cause__) == TransformerException:\\\\\\n                transform_exception = exception.__cause__\\\\\\n            else:\\\\\\n                tb = traceback.extract_tb(exception.__traceback__) \\\\\n\\\\\\n                # TODO: Make this filter condition stronger \\\\\n                transformer_frames = [ \\\\\n                    frame \\\\\n                    for frame in tb \\\\\n                    if frame.name == self.__class__.__name__ or frame.name == 'transform' \\\\\n                ] \\\\\n\\\\\\n                if len(transformer_frames) == 1:\\\\\\n                    transformer_frame = transformer_frames[0]\\\\\\n                    exception_message = (\\\\\\n                        f'\\\\\\n  '\\\\\\n                        f'File "{transformer_frame.filename}", line {transformer_frame.lineno}, '\\\\\\n                        f'in transformer "{self.__class__.__name__}"\\\\\\n  '\\\\\\n                        f'  >> {transformer_frame.line}'\\\\\\n                    )\\\\\\\\\n\\\\\\n                else:\\\\\\n                    exception_message = (\\\\\\n                        f'An error occurred in transformer "{self.__class__.__name__}"'\\\\\\n                    )\\\\\\\\\n\\\\\\n                transform_exception = TransformerException(\\\\\\\\\n                    internal_exception=exception,\\\\\\\\\n                    raiser_transformer=self,\\\\\\\\\n                    message=exception_message,\\\\\\\\\n                )\\\\\\\\\n\\\\\\n        if transform_exception is not None:\\\\\\n            raise transform_exception.internal_exception \\\\\n\\\\\\n        if type(transformed) is not None:\\\\\\n            return cast(_Out, transformed) \\\\\n\\\\\\n        raise NotImplementedError \\\\\n    def copy(self, \\\\\n        transform: Callable[[BaseTransformer, _In], Awaitable[_Out]] | None = None, \\\\\n        regenerate_instance_id: bool = False, \\\\\n    ) -> 'AsyncTransformer[_In, _Out]':\\\\\\n        copied = copy.copy(self) \\\\\n\\\\\\n        func_type = types.MethodType \\\\\n        if transform is not None: \\\\\n            setattr(copied, 'transform_async', func_type(transform, copied)) \\\\\n\\\\\\n        if regenerate_instance_id: \\\\\n            copied.instance_id = uuid.uuid4() \\\\\n\\\\\\n        if self.previous is not None: \\\\\n            if type(self.previous) == tuple: \\\\\n                new_previous: list[BaseTransformer] = [ \\\\\n                    previous_transformer.copy() for previous_transformer in self.previous \\\\\n                ] \\\\\n                copied._previous = cast(PreviousTransformer, tuple(new_previous)) \\\\\n            elif isinstance(self.previous, BaseTransformer): \\\\\n                copied._previous = self.previous.copy() \\\\\n\\\\\\n        copied._children = [ \\\\\n            child.copy(regenerate_instance_id=True) for child in self.children \\\\\n        ] \\\\\n\\\\\\n        return copied \\\\\n    @overload \\\\\n    def __rshift__( \\\\\n        self, next_node: BaseTransformer[_Out, _NextOut, Any] \\\\\n    ) -> 'AsyncTransformer[_In, _NextOut]': \\\\\n        pass \\\\\n    @overload \\\\\n    def __rshift__( \\\\\n        self, \\\\\n        next_node: tuple[ \\\\\n            BaseTransformer[_Out, _NextOut, Any], BaseTransformer[_Out, _Out2, Any] \\\\\n        ] \\\\\n    ) -> 'AsyncTransformer[_In, tuple[_NextOut, _Out2]']': \\\\\n        pass \\\\\n    @overload \\\\\n    def __rshift__( \\\\\n        self, \\\\\n        next_node: tuple[ \\\\\n            BaseTransformer[_Out, _NextOut, Any], \\\\\n            BaseTransformer[_Out, _Out2, Any], \\\\\n            BaseTransformer[_Out, _Out3, Any] \\\\\n        ] \\\\\n    ) -> 'AsyncTransformer[_In, tuple[_NextOut, _Out2, _Out3]']': \\\\\n        pass \\\\\n    @overload \\\\\n    def __rshift__( \\\\\n        self, \\\\\n        next_node: tuple[ \\\\\n            BaseTransformer[_Out, _NextOut, Any], \\\\\n            BaseTransformer[_Out, _Out2, Any], \\\\\n            BaseTransformer[_Out, _Out3, Any], \\\\\n            BaseTransformer[_Out, _Out4, Any] \\\\\n        ] \\\\\n    ) -> 'AsyncTransformer[_In, tuple[_NextOut, _Out2, _Out3, _Out4]']': \\\\\n        pass \\\\\n    @overload \\\\\n    def __rshift__( \\\\\n        self, \\\\\n        next_node: tuple[ \\\\\n            BaseTransformer[_Out, _NextOut, Any], \\\\\n            BaseTransformer[_Out, _Out2, Any], \\\\\n            BaseTransformer[_Out, _Out3, Any], \\\\\n            BaseTransformer[_Out, _Out4, Any], \\\\\n            BaseTransformer[_Out, _Out5, Any] \\\\\n        ] \\\\\n    ) -> 'AsyncTransformer[_In, tuple[_NextOut, _Out2, _Out3, _Out4, _Out5]']': \\\\\n        pass \\\\\n    @overload \\\\\n    def __rshift__( \\\\\n        self, \\\\\n        next_node: tuple[ \\\\\n            BaseTransformer[_Out, _NextOut, Any], \\\\\n            BaseTransformer[_Out, _Out2, Any], \\\\\n            BaseTransformer[_Out, _Out3, Any], \\\\\n            BaseTransformer[_Out, _Out4, Any], \\\\\n            BaseTransformer[_Out, _Out5, Any], \\\\\n            BaseTransformer[_Out, _Out6, Any] \\\\\n        ] \\\\\n    ) -> 'AsyncTransformer[_In, tuple[_NextOut, _Out2, _Out3, _Out4, _Out5, _Out6]']': \\\\\n        pass \\\\\n    @overload \\\\\n    def __rshift__( \\\\\n        self, \\\\\n        next_node: tuple[ \\\\\n            BaseTransformer[_Out, _NextOut, Any], \\\\\n            BaseTransformer[_Out, _Out2, Any], \\\\\n            BaseTransformer[_Out, _Out3, Any], \\\\\n            BaseTransformer[_Out, _Out4, Any], \\\\\n            BaseTransformer[_Out, _Out5, Any], \\\\\n            BaseTransformer[_Out, _Out6, Any], \\\\\n            BaseTransformer[_Out, _Out7, Any] \\\\\n        ] \\\\\n    ) -> 'AsyncTransformer[_In, tuple[_NextOut, _Out2, _Out3, _Out4, _Out5, _Out6, _Out7]']': \\\\\n        pass \\\\\n    def __rshift__(self, next_node): \\\\\n        pass \\\\\n}