import copy\\\\\nimport types\\\\\\\nimport uuid\\\\\\\\\nimport inspect\\\\\\\\\\\nfrom functools import cached_property\\\\\\\\\\\\\nfrom inspect import Signature\\\\\\\\\\\\\\\nimport networkx as nx\\\\\\\\\\\\\\\\\nfrom networkx import DiGraph, Graph\\\\\\\\\\\\\\\\\\\nfrom typing import (\\\\\\\\\\\\\\\\\\\n    Any, \\\\\\\\\\\\\\\\\\\n    Callable, \\\\\\\\\\\\\\\\\\\n    Generic, \\\\\\\\\\\\\\\\\\\n    TypeVar, \\\\\\\\\\\\\\\\\\\n    Union, \\\\\\\\\\\\\\\\\\\n    cast, \\\\\\\\\\\\\\\\\\\n    Iterable, \\\\\\\\\\\\\\\\\\\n    get_args, \\\\\\\\\\\\\\\\\\\n    get_origin, \\\\\\\\\\\\\\\\\\\n    TypeAlias, \\\\\\\\\\\\\\\\\\\n    Type, \\\\\\\\\\\\\\\\\\\n)\\\\\\\\\\\\\\\\\\\\nfrom uuid import UUID\\\\\\\\\\\\\\\\\\\\nfrom itertools import groupby\\\\\\\\\\\\\\\\\\\\nfrom gloe._utils import _format_return_annotation\\\\\\\\\\\\\\\\\\\\n__all__ = ["BaseTransformer", "TransformerException", "PreviousTransformer"]\\\\\\\\\\\\\\\\\\\\n_In = TypeVar("_In")\\\\\\\\\\\\\\\\\\\\n_Out = TypeVar("_Out")\\\\\\\\\\\\\\\\\\\\n_NextOut = TypeVar("_NextOut")\\\\\\\\\\\\\\\\\\\\n_Self = TypeVar("_Self", bound="BaseTransformer")\\\\\\\\\\\\\\\\\\\\n_Out2 = TypeVar("_Out2")\\\\\\\\\\\\\\\\\\\\n_Out3 = TypeVar("_Out3")\\\\\\\\\\\\\\\\\\\\n_Out4 = TypeVar("_Out4")\\\\\\\\\\\\\\\\\\\\n_Out5 = TypeVar("_Out5")\\\\\\\\\\\\\\\\\\\\n_Out6 = TypeVar("_Out6")\\\\\\\\\\\\\\\\\\\\n_Out7 = TypeVar("_Out7"]\\\\\\\\\\\\\\\\\\\\nPreviousTransformer: TypeAlias = Union[\\\\\\\\\\\\\\\\\\\\n    None, \\\\\\\\\\\\\\\\\\\n    _Self, \\\\\\\\\\\\\\\\\\\n    tuple[_Self, _Self], \\\\\\\\\\\\\\\\\\\n    tuple[_Self, _Self, _Self], \\\\\\\\\\\\\\\\\\\n    tuple[_Self, _Self, _Self, _Self], \\\\\\\\\\\\\\\\\\\n    tuple[_Self, _Self, _Self, _Self, _Self], \\\\\\\\\\\\\\\\\\\n    tuple[_Self, _Self, _Self, _Self, _Self, _Self], \\\\\\\\\\\\\\\\\\\n    tuple[_Self, _Self, _Self, _Self, _Self, _Self, _Self], \\\\\\\\\\\\\\\\\\\n]\\\\\\\\\\\\\\\\\\\\nclass TransformerException(Exception):\\\\\\\\\\\\\\\\\\\n    def __init__(self, \\\\\\\\\\\\\\\\\\\n        internal_exception: Union["TransformerException", Exception], \\\\\\\\\\\\\\\\\\\n        raiser_transformer: "BaseTransformer", \\\\\\\\\\\\\\\\\\\n        message: str | None = None, \\\\\\\\\\\\\\\\\\\n    ): \\\\\\\\\\\\\\\\\\\n        self._internal_exception = internal_exception \\\\\\\\\\\\\\\\\\\n        self.raiser_transformer = raiser_transformer \\\\\\\\\\\\\\\\\\\n        self._traceback = internal_exception.__traceback__ \\\\\\\\\\\\\\\\\\\n        internal_exception.__cause__ = self \\\\\\\\\\\\\\\\\\\n        super().__init__(message) \\\\\\\\\\\\\\\\\\\n    @property \\\\\\\\\\\\\\\\\\\n    def internal_exception(self): \\\\\\\\\\\\\\\\\\\n        return self._internal_exception.with_traceback(self._traceback) \\\\\\\\\\\\\\\\\\\nclass BaseTransformer(Generic[_In, _Out, _Self]):\\\\\\\\\\\\\\\\\\\n    def __init__(self): \\\\\\\\\\\\\\\\\\\n        self._previous: PreviousTransformer[_Self] = None \\\\\\\\\\\\\\\\\\\n        self._children: list["BaseTransformer"] = [] \\\\\\\\\\\\\\\\\\\n        self._invisible = False \\\\\\\\\\\\\\\\\\\n        self.id = uuid.uuid4() \\\\\\\\\\\\\\\\\\\n        self.instance_id = uuid.uuid4() \\\\\\\\\\\\\\\\\\\n        self._label = self.__class__.__name__ \\\\\\\\\\\\\\\\\\\n        self._graph_node_props: dict[str, Any] = {"shape": "box"} \\\\\\\\\\\\\\\\\\\n        self.events = [] \\\\\\\\\\\\\\\\\\\n    @property \\\\\\\\\\\\\\\\\\\n    def label(self) -> str: \\\\\\\\\\\\\\\\\\\n        return self._label \\\\\\\\\\\\\\\\\\\n    @property \\\\\\\\\\\\\\\\\\\n    def graph_node_props(self) -> dict[str, Any]: \\\\\\\\\\\\\\\\\\\n        return self._graph_node_props \\\\\\\\\\\\\\\\\\\n    @property \\\\\\\\\\\\\\\\\\\n    def children(self) -> list["BaseTransformer"]: \\\\\\\\\\\\\\\\\\\n        return self._children \\\\\\\\\\\\\\\\\\\n    @property \\\\\\\\\\\\\\\\\\\n    def previous(self) -> PreviousTransformer[_Self]: \\\\\\\\\\\\\\\\\\\n        return self._previous \\\\\\\\\\\\\\\\\\\n    @property \\\\\\\\\\\\\\\\\\\n    def invisible(self) -> bool: \\\\\\\\\\\\\\\\\\\n        return self._invisible \\\\\\\\\\\\\\\\\\\n    def __hash__(self) -> int: \\\\\\\\\\\\\\\\\\\n        return hash(self.id) \\\\\\\\\\\\\\\\\\\n    def __eq__(self, other): \\\\\\\\\\\\\\\\\\\n        if isinstance(other, BaseTransformer): \\\\\\\\\\\\\\\\\\\n            return self.id == other.id \\\\\\\\\\\\\\\\\\\n        return NotImplemented \\\\\\\\\\\\\\\\\\\n    def copy(self, \\\\\\\\\\\\\\\\\\\n        transform: Callable[[_Self, _In], _Out] | None = None, \\\\\\\\\\\\\\\\\\\n        regenerate_instance_id: bool = False, \\\\\\\\\\\\\\\\\\\n    ) -> _Self: \\\\\\\\\\\\\\\\\\\n        copied = copy.copy(self) \\\\\\\\\\\\\\\\\\\n        func_type = types.MethodType \\\\\\\\\\\\\\\\\\\n        if transform is not None: \\\\\\\\\\\\\\\\\\\n            setattr(copied, "transform", func_type(transform, copied)) \\\\\\\\\\\\\\\\\\\n        if regenerate_instance_id: \\\\\\\\\\\\\\\\\\\n            copied.instance_id = uuid.uuid4() \\\\\\\\\\\\\\\\\\\n        if self.previous is not None: \\\\\\\\\\\\\\\\\\\n            if type(self.previous) == tuple: \\\\\\\\\\\\\\\\\\\n                new_previous: list[_Self] = [ \\\\\\\\\\\\\\\\\\\n                    previous_transformer.copy() for previous_transformer in self.previous \\\\\\\\\\\\\\\\\\\n                ] \\\\\\\\\\\\\\\\\\\n                copied._previous = cast(PreviousTransformer, tuple(new_previous)) \\\\\\\\\\\\\\\\\\\n            elif isinstance(self.previous, BaseTransformer): \\\\\\\\\\\\\\\\\\\n                copied._previous = self.previous.copy() \\\\\\\\\\\\\\\\\\\n        copied._children = [ \\\\\\\\\\\\\\\\\\\n            child.copy(regenerate_instance_id=True) for child in self.children \\\\\\\\\\\\\\\\\\\n        ] \\\\\\\\\\\\\\\\\\\n        return copied \\\\\\\\\\\\\\\\\\\n    @property \\\\\\\\\\\\\\\\\\\n    def graph_nodes(self) -> dict[UUID, "BaseTransformer"]: \\\\\\\\\\\\\\\\\\\n        nodes = {self.instance_id: self} \\\\\\\\\\\\\\\\\\\n        if self.previous is not None: \\\\\\\\\\\\\\\\\\\n            if type(self.previous) == tuple: \\\\\\\\\\\\\\\\\\\n                for prev in self.previous: \\\\\\\\\\\\\\\\\\\n                    nodes = {**nodes, **prev.graph_nodes} \\\\\\\\\\\\\\\\\\\n            elif isinstance(self.previous, BaseTransformer): \\\\\\\\\\\\\\\\\\\n                nodes = {**nodes, **self.previous.graph_nodes} \\\\\\\\\\\\\\\\\\\n        for child in self.children: \\\\\\\\\\\\\\\\\\\n            nodes = {**nodes, **child.graph_nodes} \\\\\\\\\\\\\\\\\\\n        return nodes \\\\\\\\\\\\\\\\\\\n    def _set_previous(self, previous: PreviousTransformer): \\\\\\\\\\\\\\\\\\\n        if self.previous is None: \\\\\\\\\\\\\\\\\\\n            self._previous = previous \\\\\\\\\\\\\\\\\\\n        elif type(self.previous) == tuple: \\\\\\\\\\\\\\\\\\\n            for previous_transformer in self.previous: \\\\\\\\\\\\\\\\\\\n                previous_transformer._set_previous(previous) \\\\\\\\\\\\\\\\\\\n        elif isinstance(self.previous, BaseTransformer): \\\\\\\\\\\\\\\\\\\n            self.previous._set_previous(previous) \\\\\\\\\\\\\\\\\\\n    def signature(self) -> Signature: \\\\\\\\\\\\\\\\\\\n        return self._signature(type(self)) \\\\\\\\\\\\\\\\\\\n    def _signature(self, klass: Type) -> Signature: \\\\\\\\\\\\\\\\\\\n        orig_bases = getattr(self, "__orig_bases__", []) \\\\\\\\\\\\\\\\\\\n        transformer_args = [ \\\\\\\\\\\\\\\\\\\n            get_args(base) for base in orig_bases if get_origin(base) == klass \\\\\\\\\\\\\\\\\\\n        ] \\\\\\\\\\\\\\\\\\\n        generic_args = [ \\\\\\\\\\\\\\\\\\\n            get_args(base) for base in orig_bases if get_origin(base) == Generic \\\\\\\\\\\\\\\\\\\n        ] \\\\\\\\\\\\\\\\\\\n        orig_class = getattr(self, "__orig_class__", None) \\\\\\\\\\\\\\\\\\\n        specific_args = {} \\\\\\\\\\\\\\\\\\\n        if ( \\\\\\\\\\\\\\\\\\\n            len(transformer_args) == 1 \\\\\\\\\\\\\\\\\\\n            and len(generic_args) == 1 \\\\\\\\\\\\\\\\\\\n            and orig_class is not None \\\\\\\\\\\\\\\\\\\n        ): \\\\\\\\\\\\\\\\\\\n            generic_arg = generic_args[0] \\\\\\\\\\\\\\\\\\\n            transformer_arg = transformer_args[0] \\\\\\\\\\\\\\\\\\\n            specific_args = { \\\\\\\\\\\\\\\\\\\n                generic: specific \\\\\\\\\\\\\\\\\\\n                for generic, specific in zip(generic_arg, get_args(orig_class)) \\\\\\\\\\\\\\\\\\\n                if generic in transformer_arg \\\\\\\\\\\\\\\\\\\n            } \\\\\\\\\\\\\\\\\\\n        signature = inspect.signature(self.transform) \\\\\\\\\\\\\\\\\\\n        new_return_annotation = specific_args.get( \\\\\\\\\\\\\\\\\\\n            signature.return_annotation, signature.return_annotation \\\\\\\\\\\\\\\\\\\n        ) \\\\\\\\\\\\\\\\\\\n        parameters = list(signature.parameters.values()) \\\\\\\\\\\\\\\\\\\n        if len(parameters) > 0: \\\\\\\\\\\\\\\\\\\n            parameter = parameters[0] \\\\\\\\\\\\\\\\\\\n            parameter = parameter.replace( \\\\\\\\\\\\\\\\\\\n                annotation=specific_args.get(parameter.annotation, parameter.annotation) \\\\\\\\\\\\\\\\\\\n            ) \\\\\\\\\\\\\\\\\\\n            return signature.replace( \\\\\\\\\\\\\\\\\\\n                return_annotation=new_return_annotation, \\\\\\\\\\\\\\\\\\\n                parameters=[parameter], \\\\\\\\\\\\\\\\\\\n            ) \\\\\\\\\\\\\\\\\\\n        return signature.replace(return_annotation=new_return_annotation) \\\\\\\\\\\\\\\\\\\n    @property \\\\\\\\\\\\\\\\\\\n    def output_type(self) -> Any: \\\\\\\\\\\\\\\\\\\n        signature = self.signature() \\\\\\\\\\\\\\\\\\\n        return signature.return_annotation \\\\\\\\\\\\\\\\\\\n    @property \\\\\\\\\\\\\\\\\\\n    def output_annotation(self) -> str: \\\\\\\\\\\\\\\\\\\n        output_type = self.output_type \\\\\\\\\\\\\\\\\\\n        return_type = _format_return_annotation(output_type, None, None) \\\\\\\\\\\\\\\\\\\n        return return_type \\\\\\\\\\\\\\\\\\\n    @property \\\\\\\\\\\\\\\\\\\n    def input_type(self) -> Any: \\\\\\\\\\\\\\\\\\\n        parameters = list(self.signature().parameters.items()) \\\\\\\\\\\\\\\\\\\n        if len(parameters) > 0: \\\\\\\\\\\\\\\\\\\n            parameter_type = parameters[0][1].annotation \\\\\\\\\\\\\\\\\\\n            return parameter_type \\\\\\\\\\\\\\\\\\\n    @property \\\\\\\\\\\\\\\\\\\n    def input_annotation(self) -> str: \\\\\\\\\\\\\\\\\\\n        return self.input_type.__name__ \\\\\\\\\\\\\\\\\\\n    def _add_net_node(self, net: Graph, custom_data: dict[str, Any] = {}): \\\\\\\\\\\\\\\\\\\n        node_id = self.node_id \\\\\\\\\\\\\\\\\\\n        props = {**self.graph_node_props, **custom_data, "label": self.label} \\\\\\\\\\\\\\\\\\\n        if node_id not in net.nodes: \\\\\\\\\\\\\\\\\\\n            net.add_node(node_id, **props) \\\\\\\\\\\\\\\\\\\n        else: \\\\\\\\\\\\\\\\\\\n            nx.set_node_attributes(net, {node_id: props}) \\\\\\\\\\\\\\\\\\\n        return node_id \\\\\\\\\\\\\\\\\\\n    def _add_child_node( \\\\\\\\\\\\\\\\\\\n        self, \\\\\\\\\\\\\\\\\\\n        child: "BaseTransformer", \\\\\\\\\\\\\\\\\\\n        child_net: DiGraph, \\\\\\\\\\\\\\\\\\\n        parent_id: str, \\\\\\\\\\\\\\\\\\\n        next_node: "BaseTransformer", \\\\\\\\\\\\\\\\\\\n    ): \\\\\\\\\\\\\\\\\\\n        child._dag( \\\\\\\\\\\\\\\\\\\n            child_net, \\\\\\\\\\\\\\\\\\\n            next_node, \\\\\\\\\\\\\\\\\\\n            {"parent_id": parent_id, "bounding_box": True, "box_label": "mapping"}, \\\\\\\\\\\\\\\\\\\n        ) \\\\\\\\\\\\\\\\\\\n    @property \\\\\\\\\\\\\\\\\\\n    def node_id(self) -> str: \\\\\\\\\\\\\\\\\\\n        return str(self.instance_id) \\\\\\\\\\\\\\\\\\\n    @cached_property \\\\\\\\\\\\\\\\\\\n    def visible_previous(self) -> PreviousTransformer[_Self]: \\\\\\\\\\\\\\\\\\\n        previous = self.previous \\\\\\\\\\\\\\\\\\\n        if isinstance(previous, BaseTransformer): \\\\\\\\\\\\\\\\\\\n            if previous.invisible: \\\\\\\\\\\\\\\\\\\n                if previous.previous is None: \\\\\\\\\\\\\\\\\\\n                    return previous \\\\\\\\\\\\\\\\\\\n                if type(previous.previous) == tuple: \\\\\\\\\\\\\\\\\\\n                    return previous.previous \\\\\\\\\\\\\\\\\\\n                return previous.visible_previous \\\\\\\\\\\\\\\\\\\n            else: \\\\\\\\\\\\\\\\\\\n                return previous \\\\\\\\\\\\\\\\\\\n        return previous \\\\\\\\\\\\\\\\\\\n    def _add_children_subgraph(self, net: DiGraph, next_node: 