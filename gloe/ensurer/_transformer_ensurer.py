import inspect\\nfrom abc import abstractmethod, ABC\\nfrom types import FunctionType\\nfrom typing import Any, Callable, Generic, ParamSpec, Sequence, TypeVar, cast, overload\\n\\nfrom gloe.async_transformer import AsyncTransformer\\nfrom gloe.functional import _PartialTransformer, _PartialAsyncTransformer\\nfrom gloe.transformers import Transformer\\n\\n_T = TypeVar("_T")\n_S = TypeVar("_S")\n_U = TypeVar("_U")\n_P1 = ParamSpec("_P1")\n\\nclass TransformerEnsurer(Generic[_T, _S], ABC):\\n    @abstractmethod\\n    def validate_input(self, data: _T):\\n        """Perform a validation on incoming data before execute the transformer code"""\\n\\n    @abstractmethod\\n    def validate_output(self, data: _T, output: _S):\\n        """Perform a validation on outcome data after execute the transformer code"""\\n\\n    def __call__(self, transformer: Transformer[_T, _S]) -> Transformer[_T, _S]:\\n        def transform(this: Transformer, data: _T) -> _S:\\n            self.validate_input(data)\\n            output = transformer.transform(data)\\n            self.validate_output(data, output)\\n            return output\\n\\n        transformer_cp = transformer.copy(transform)\\n        return transformer_cp\\n\\nclass _ensure_base:\\n    @overload\\n    def __call__(self, transformer: Transformer[_U, _S]) -> Transformer[_U, _S]:\\n        pass\\n\\n    @overload\\n    def __call__(self, transformer_init: _PartialTransformer[_T, _P1, _U]) -> _PartialTransformer[_T, _P1, _U]:\\n        pass\\n\\n    @overload\\n    def __call__(self, transformer: AsyncTransformer[_U, _S]) -> AsyncTransformer[_U, _S]:\\n        pass\\n\\n    @overload\\n    def __call__(self, transformer_init: _PartialAsyncTransformer[_T, _P1, _U]) -> _PartialAsyncTransformer[_T, _P1, _U]:\\n        pass\\n\\n    def __call__(self, arg):\\n        if isinstance(arg, Transformer):\\n            return self._generate_new_transformer(arg)\\n        if isinstance(arg, AsyncTransformer):\\n            return self._generate_new_async_transformer(arg)\\n        if isinstance(arg, _PartialTransformer):\\n            transformer_init = arg\\n            def ensured_transformer_init(*args, **kwargs):\\n                transformer = transformer_init(*args, **kwargs)\\n                return self._generate_new_transformer(transformer)\\n            return ensured_transformer_init\\n        if isinstance(arg, _PartialAsyncTransformer):\\n            async_transformer_init = arg\\n            async def ensured_async_transformer_init(*args, **kwargs):\\n                async_transformer = async_transformer_init(*args, **kwargs)\\n                return self._generate_new_async_transformer(async_transformer)\\n            return ensured_async_transformer_init\\n\\n    @abstractmethod\\n    def _generate_new_transformer(self, transformer: Transformer) -> Transformer:\\n        pass\\n\\n    @abstractmethod\\n    def _generate_new_async_transformer(self, transformer: AsyncTransformer) -> AsyncTransformer:\\n        pass\\n\\nclass _ensure_incoming(Generic[_T], _ensure_base):\\n    def __init__(self, incoming: Sequence[Callable[[_T], Any]]):\\n        self.input_ensurers_instances = [input_ensurer(ensurer) for ensurer in incoming]\\n\\n    def _generate_new_transformer(self, transformer: Transformer) -> Transformer:\\n        def transform(_, data):\\n            for ensurer in self.input_ensurers_instances:\\n                ensurer.validate_input(data)\\n            output = transformer.transform(data)\\n            return output\\n\\n        transformer_cp = transformer.copy(transform)\\n        return transformer_cp\\n\\n    def _generate_new_async_transformer(self, transformer: AsyncTransformer) -> AsyncTransformer:\\n        async def transform_async(_, data):\\n            for ensurer in self.input_ensurers_instances:\\n                ensurer.validate_input(data)\\n            output = await transformer.transform_async(data)\\n            return output\\n\\n        transformer_cp = transformer.copy(transform_async)\\n        return transformer_cp\\n\\nclass _ensure_outcome(Generic[_S], _ensure_base):\\n    def __init__(self, incoming: Sequence[Callable[[_S], Any]]):\\n        self.output_ensurers_instances = [output_ensurer(ensurer) for ensurer in incoming]\\n\\n    def _generate_new_transformer(self, transformer: Transformer) -> Transformer:\\n        def transform(_, data):\\n            output = transformer.transform(data)\\n            for ensurer in self.output_ensurers_instances:\\n                ensurer.validate_output(data, output)\\n            return output\\n\\n        transformer_cp = transformer.copy(transform)\\n        return transformer_cp\\n\\n    def _generate_new_async_transformer(self, transformer: AsyncTransformer) -> AsyncTransformer:\\n        async def transform_async(_, data):\\n            output = await transformer.transform_async(data)\\n            for ensurer in self.output_ensurers_instances:\\n                ensurer.validate_output(data, output)\\n            return output\\n\\n        transformer_cp = transformer.copy(transform_async)\\n        return transformer_cp\\n\\nclass _ensure_changes(Generic[_T, _S], _ensure_base):\\n    def __init__(self, changes: Sequence[Callable[[_T, _S], Any]]):\\n        self.changes_ensurers_instances = [output_ensurer(ensurer) for ensurer in changes]\\n\\n    def _generate_new_transformer(self, transformer: Transformer) -> Transformer:\\n        def transform(_, data):\\n            output = transformer.transform(data)\\n            for ensurer in self.changes_ensurers_instances:\\n                ensurer.validate_output(data, output)\\n            return output\\n\\n        transformer_cp = transformer.copy(transform)\\n        return transformer_cp\\n\\n    def _generate_new_async_transformer(self, transformer: AsyncTransformer) -> AsyncTransformer:\\n        async def transform_async(_, data):\\n            output = await transformer.transform_async(data)\\n            for ensurer in self.changes_ensurers_instances:\\n                ensurer.validate_output(data, output)\\n            return output\\n\\n        transformer_cp = transformer.copy(transform_async)\\n        return transformer_cp\\n\\nclass _ensure_both(Generic[_T, _S], _ensure_base):\\n    def __init__(self, incoming: Sequence[Callable[[_T], Any]], outcome: Sequence[Callable[[_S], Any]], changes: Sequence[Callable[[_T, _S], Any]]):\\n        incoming_seq = incoming if type(incoming) == list else [incoming]\\n        self.input_ensurers_instances = [input_ensurer(ensurer) for ensurer in incoming_seq]\\n\\n        outcome_seq = outcome if type(outcome) == list else [outcome]\\n        self.output_ensurers_instances = [output_ensurer(ensurer) for ensurer in outcome_seq]\\n\\n        changes_seq = changes if type(changes) == list else [changes]\\n        self.output_ensurers_instances = self.output_ensurers_instances + [output_ensurer(ensurer) for ensurer in changes_seq]\\n\\n    def _generate_new_transformer(self, transformer: Transformer) -> Transformer:\\n        def transform(_, data):\\n            for ensurer in self.input_ensurers_instances:\\n                ensurer.validate_input(data)\\n            output = transformer.transform(data)\\n            for ensurer in self.output_ensurers_instances:\\n                ensurer.validate_output(data, output)\\n            return output\\n\\n        transformer_cp = transformer.copy(transform)\\n        return transformer_cp\\n\\n    def _generate_new_async_transformer(self, transformer: AsyncTransformer) -> AsyncTransformer:\\n        async def transform_async(_, data):\\n            for ensurer in self.input_ensurers_instances:\\n                ensurer.validate_input(data)\\n            output = await transformer.transform_async(data)\\n            for ensurer in self.output_ensurers_instances:\\n                ensurer.validate_output(data, output)\\n            return output\\n\\n        transformer_cp = transformer.copy(transform_async)\\n        return transformer_cp\\n\\n@overload\\ndef ensure(incoming: Sequence[Callable[[_T], Any]]) -> _ensure_incoming[_T]:\\n    pass\\n\\n@overload\\ndef ensure(outcome: Sequence[Callable[[_S], Any]]) -> _ensure_outcome[_S]:\\n    pass\\n\\n@overload\\ndef ensure(changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_changes[_T, _S]:\\n    pass\\n\\n@overload\\ndef ensure(incoming: Sequence[Callable[[_T], Any]], outcome: Sequence[Callable[[_S], Any]]) -> _ensure_both[_T, _S]:\\n    pass\\n\\n@overload\\ndef ensure(incoming: Sequence[Callable[[_T], Any]], changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_both[_T, _S]:\\n    pass\\n\\n@overload\\ndef ensure(outcome: Sequence[Callable[[_T], Any]], changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_both[_T, _S]:\\n    pass\\n\\n@overload\\ndef ensure(incoming: Sequence[Callable[[_T], Any]], outcome: Sequence[Callable[[_S], Any]], changes: Sequence[Callable[[_T, _S], Any]]) -> _ensure_both[_T, _S]:\\n    pass\\n\\ndef ensure(*args, **kwargs):\\n    """\\n    This decorator is used in transformers to ensure some validation based on its incoming data, outcome data, or both.\\n\\n    These validations are performed by validators. Validators are simple callable functions that validate certain aspects of the input, output, or the differences between them. If the validation fails, it must raise an exception.\\n\\n    The decorator :code:`@ensure` returns some intermediate classes to assist with the internal logic of Gloe. However, the result of applying it to a transformer is just a new transformer with the exact same attributes, but it includes an additional validation layer.\\n\\n    The motivation of the many overloads is just to allow the user to define different types of validators interchangeably.\\n\\n    See also:\\n        For more detailed information about this feature, refer to the :ref:`ensurers` page.\\n\\n    Args:\\n        incoming (Sequence[Callable[[_T], Any]]): sequence of validators that will be applied to the incoming data. The type :code:`_T` refers to the incoming type. Defaut value: :code:`[]`.\\n        outcome (Sequence[Callable[[_S], Any]]): sequence of validators that will be applied to the outcome data. The type :code:`_S` refers to the outcome type. Defaut value: :code:`[]`.\\n        changes (Sequence[Callable[[_T, _S], Any]]): sequence of validators that will be applied to both incoming and outcome data. The type :code:`_T` refers to the incoming type, and type :code:`_S` refers to the outcome type. Defaut value: :code:`[]`.\\n    """\\n    if len(kwargs.keys()) == 1 and "incoming" in kwargs:\\n        return _ensure_incoming(kwargs["incoming"]) \\n\\n    if len(kwargs.keys()) == 1 and "outcome" in kwargs:\\n        return _ensure_outcome(kwargs["outcome"]) \\n\\n    if len(kwargs.keys()) == 1 and "changes" in kwargs:\\n        return _ensure_changes(kwargs["changes"]) \\n\\n    if len(kwargs.keys()) > 1:\\n        incoming = []\\n        if "incoming" in kwargs:\\n            incoming = kwargs["incoming"]\\n\\n        outcome = []\\n        if "outcome" in kwargs:\\n            outcome = kwargs["outcome"]\\n\\n        changes = []\\n        if "changes" in kwargs:\\n            changes = kwargs["changes"]\\n\\n        return _ensure_both(incoming, outcome, changes)\\n