import traceback\\\nfrom abc import ABC, abstractmethod\\\\nfrom inspect import Signature\\\\nfrom typing import TypeVar, overload, cast, Any, Union, TypeAlias\\\\nfrom gloe.base_transformer import BaseTransformer, TransformerException\\\\nfrom gloe.async_transformer import AsyncTransformer\\\\n\n__all__ = ['Transformer']\\\\n\nI = TypeVar('I')\\\nO = TypeVar('O')\\\nO1 = TypeVar('O1')\\\nO2 = TypeVar('O2')\\\nO3 = TypeVar('O3')\\\nO4 = TypeVar('O4')\\\nO5 = TypeVar('O5')\\\nO6 = TypeVar('O6')\\\nO7 = TypeVar('O7')\\\n\nTr: TypeAlias = 'Transformer'\\\\nAT: TypeAlias = AsyncTransformer\\\\nBT: TypeAlias = BaseTransformer[I, O, Any]\\\\n\nAsyncNext2 = Union[\\\\\\\n    tuple[AT[O, O1], BT[O, O2]],\\\\\\\n    tuple[BT[O, O1], AT[O, O2]],\\\\\\\n]\\\\n\nAsyncNext3 = Union[\\\\\\\n    tuple[AT[O, O1], BT[O, O2], BT[O, O3]],\\\\\\\n    tuple[BT[O, O1], AT[O, O2], BT[O, O3]],\\\\\\\n    tuple[BT[O, O1], BT[O, O2], AT[O, O3]],\\\\\\\n]\\\\n\nAsyncNext4 = Union[\\\\\\\n    tuple[AT[O, O1], BT[O, O2], BT[O, O3], BT[O, O4]],\\\\\\\n    tuple[BT[O, O1], AT[O, O2], BT[O, O3], BT[O, O4]],\\\\\\\n    tuple[BT[O, O1], BT[O, O2], AT[O, O3], BT[O, O4]],\\\\\\\n    tuple[BT[O, O1], BT[O, O2], BT[O, O3], AT[O, O4]],\\\\\\\n]\\\\n\nclass Transformer(BaseTransformer[I, O, 'Transformer'], ABC):\\\\n    '''\\\\\\\n    A Transformer is the generic block with the responsibility to take an input of type\\\\\\\n    `I` and transform it to an output of type `O`.\\\\\\\n    \\\\\\\n    See Also:\\\\\\\n        Read more about this feature in the page :ref:`creating-a-transformer`.\\\\\\\n    \\\\\\\n    Example:\\\\\\n        Typical usage example::\\\n            \\\\\\n            class Stringifier(Transformer[dict, str]):\\\\\\n                ...\\\\\\n    '''\\\\\\\n    def __init__(self):\\\\\\n        super().__init__()\\\\\\n        self.__class__.__annotations__ = self.transform.__annotations__\\\\\\n\n    @abstractmethod\\\\\\n    def transform(self, data: I) -> O:\\\\\\n        '''Main method to be implemented and responsible to perform the transformer logic\\\\\\n        '''\\\\\\n\n    def signature(self) -> Signature:\\\\\\n        return self._signature(Transformer)\\\\\\n\n    def __repr__(self):\\\\\\n        return f"{self.input_annotation} -> ({type(self).__name__}) -> {self.output_annotation}"\\\\\\n\n    def __call__(self, data: I) -> O:\\\\\\n        transform_exception = None\\\\\\n\n        transformed: O | None = None\\\\\\n        try:\\\\\\n            transformed = self.transform(data)\\\\\\n        except Exception as exception:\\\\\\n            if type(exception.__cause__) == TransformerException:\\\\\\n                transform_exception = exception.__cause__\\\\\\n            else:\\\\\\n                tb = traceback.extract_tb(exception.__traceback__)\\\\\\n\n                # TODO: Make this filter condition stronger\\\\\\n                transformer_frames = [\\\\\\\n                    frame\\\\\\\n                    for frame in tb\\\\\\\n                    if frame.name == self.__class__.__name__ or frame.name == 'transform'\\\\\\\n                ]\\\\\\n\n                if len(transformer_frames) == 1:\\\\\\n                    transformer_frame = transformer_frames[0]\\\\\\n                    exception_message = (\\\\\\\n                        f'\\\\\\n  '\\\\\\n                        f'File "{transformer_frame.filename}", line {transformer_frame.lineno}, '\\\\\\n                        f'in transformer "{self.__class__.__name__}"\\\\\\n  '\\\\\\n                        f'  >> {transformer_frame.line}'\\\\\\n                    )\\\\\\n                else:\\\\\\n                    exception_message = (\\\\\\\n                        f'An error occurred in transformer "{self.__class__.__name__}"'\\\\\\n                    )\\\\\\n\n                transform_exception = TransformerException(\\\\\\\n                    internal_exception=exception,\\\\\\\n                    raiser_transformer=self,\\\\\\\n                    message=exception_message,\\\\\\\n                )\\\\\\n\n        if transform_exception is not None:\\\\\\n            raise transform_exception.internal_exception\\\\\\n\n        if type(transformed) is not None:\\\\\\n            return cast(O, transformed)\\\\\\n\n        raise NotImplementedError\\\\\\n\n    @overload\\\\\\n    def __rshift__(self, next_node: 'Tr[O, O1]') -> 'Tr[I, O1]':\\\\\\n        pass\\\\\\n\n    @overload\\\\\\n    def __rshift__(self, next_node: AT[O, O1]) -> AT[I, O1]:\\\\\\n        pass\\\\\\n\n    @overload\\\\\\n    def __rshift__(self, next_node: AsyncNext2[O, O1, O2]) -> AT[I, tuple[O1, O2]]:\\\\\\n        pass\\\\\\n\n    @overload\\\\\\n    def __rshift__(self, next_node: AsyncNext3[O, O1, O2, O3]) -> AT[I, tuple[O1, O2, O3]]:\\\\\\n        pass\\\\\\n\n    @overload\\\\\\n    def __rshift__(self, next_node: AsyncNext4[O, O1, O2, O3, O4]) -> AT[I, tuple[O1, O2, O3, O4]]:\\\\\\n        pass\\\\\\n\n    @overload\\\\\\n    def __rshift__(self, next_node: AsyncNext5[O, O1, O2, O3, O4, O5]) -> AT[I, tuple[O1, O2, O3, O4, O5]]:\\\\\\n        pass\\\\\\n\n    @overload\\\\\\n    def __rshift__(self, next_node: AsyncNext6[O, O1, O2, O3, O4, O5, O6]) -> AT[I, tuple[O1, O2, O3, O4, O5, O6]]:\\\\\\n        pass\\\\\\n\n    @overload\\\\\\n    def __rshift__(self, next_node: AsyncNext7[O, O1, O2, O3, O4, O5, O6, O7]) -> AT[I, tuple[O1, O2, O3, O4, O5, O6, O7]]:\\\\\\n        pass\\\\\\n\n    def __rshift__(self, next_node):\\\\\\n        pass\\\\\\n